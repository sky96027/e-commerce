### 문제가 되는 이유

도메인 별로 트랜잭션이 분리가 된다면 모두 성공하거나 모두 실패하는 해당 로직의 원자성이 깨지게 된다는 것과 같은 말이 된다.

### 문제가 되는 이유

1. 부분 커밋 & 보상 실패

   만약 특정 단계에서 실패했고 보상 트랜잭션도 실패, 혹은 중복 수행할 경우 데이터 정합성이 깨져버린다.

2. 중복 실행, 재시도로 인한 중복 차감

   네트워크 타임아웃 등으로 Orchestrator가 재시도 시 요청이 다시 실행될 수 있다.

   재고/잔액/쿠폰 변경은 멱등성 있게 설계가 필요하다.

3. 이벤트 전달 신뢰성

   `eventPublisher.publishEvent(...)` 의 경우 동일 프로세스 내 이벤트일 뿐 트랜잭셔널 메시징이 아니므로 이벤트 유실이 충분히 가능하다.

4. 모니터링/추적의 난이도 증가

   여러 로컬 트랜잭션을 지나므로 실패 지점 파악이 어려움


### 문제의 해결 방법

**kafka 도입**

kafka를 도입한다면 트랜잭션을 분리함으로써 일어나는 문제 중 대부분을 해결 가능하다.

1. 이벤트 유실 방지

   커밋 후 이벤트를 안전하게 전달하며 `@TransactionalEventListener` 로 전달되는 이벤트보다 전달 보정이 강하다.

2. 아웃박스 + CDC

   Debezium 등의 조합으로 커밋 = 이벤트의 발행이 보장되며 유실/중복이 최소화된다.

3. 정확히 한 번 처리(Exactly-once) 시멘틱 지원

   멱등 프로듀서/트랜잭션 소비자 조합으로 중복 생산, 소비를 기술적으로 완화시킨다. 그래도 소비자 멱등성은 유지하여야 한다.

4. 모니터링/추적 개선

   토픽을 소스로 재처리/리플레이에 용이해 모니터링과 추적의 난이도를 개선시킨다.