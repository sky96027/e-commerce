### 트랜잭션 분리
이 전 PaymentFacade는 재고 차감, 잔액 차감, 쿠폰 상태 변경 등의 메서드들을 차례로 실행하고 실패 시 한 번에 RollBack 시키는 구조였다.

이 경우 트랜잭션의 길이가 길어지거나 다른 메서드들은 빠른 시간 내에 완료되는데 하나의 메서드가 길어질 경우 전체 트랜잭션이 필요 이상으로 길어져 데드락을 유발할 수 있다.

또한 주요 메서드가 전부 완료되었는데 중요도가 떨어지는 메서드가 실패해 RollBack 된다면 자원의 손해로 이어진다.

### 해결 방법
트랜잭션을 분리해 소규모로 나눠야한다. 

saga 패턴을 도입해야 하는데 orchestrator와 choreography 중 나의 프로젝트는 orchestrator 역할을 수행할 facade가 이미 있으므로 orchestrator를 선택했다.

facade에서 @Transactional을 삭제하고 각각의 메서드에 @Transactional을 선언하고 실패 시 보상 로직을 구성했다.

### saga패턴 도입 시 발생할 문제

도메인 별로 트랜잭션이 분리가 된다면 모두 성공하거나 모두 실패하는 해당 로직의 원자성이 깨지게 된다는 것과 같은 말이 된다.

1. 부분 커밋 & 보상 실패

   만약 특정 단계에서 실패했고 보상 트랜잭션도 실패, 혹은 중복 수행할 경우 데이터 정합성이 깨져버린다.

2. 중복 실행, 재시도로 인한 중복 차감

   네트워크 타임아웃 등으로 orchestrator가 재시도 시 요청이 다시 실행될 수 있다.

   재고/잔액/쿠폰 변경은 멱등성 있게 설계가 필요하다.

3. 이벤트 전달 신뢰성

   `eventPublisher.publishEvent(...)` 의 경우 동일 프로세스 내 이벤트일 뿐 트랜잭셔널 메시징이 아니므로 이벤트 유실이 충분히 가능하다.

4. 모니터링/추적의 난이도 증가

   여러 로컬 트랜잭션을 지나므로 실패 지점 파악이 어려움


### 문제의 해결 방법

**kafka 도입**

kafka를 도입한다면 트랜잭션을 분리함으로써 일어나는 문제 중 대부분을 해결 가능하다.

1. 이벤트 유실 방지

   커밋 후 이벤트를 안전하게 전달하며 `@TransactionalEventListener` 로 전달되는 이벤트보다 전달 보정이 강하다.

2. 아웃박스 + CDC

   Debezium 등의 조합으로 커밋 = 이벤트의 발행이 보장되며 유실/중복이 최소화된다.

3. 정확히 한 번 처리(Exactly-once) 시멘틱 지원

   멱등 프로듀서/트랜잭션 소비자 조합으로 중복 생산, 소비를 기술적으로 완화시킨다. 그래도 소비자 멱등성은 유지하여야 한다.
