## 문제 식별 및 분석

현재 서비스의 주요 서비스에 대해 동시성 문제가 일어날 수 있는 사안들을 정리합니다.

1. 선착순 쿠폰

   선착순 쿠폰의 경우 많은 사용자들의 동시 다발적인 요청으로 인해 쿠폰 발급 테이블(COUPON_ISSUE)의 잔량(remaining) 의 차감 로직에 대하여 충돌이 예상됩니다.

2. 상품 재고 감소

   현재 서비스에서 다수의 사용자가 동일 상품 결제 시 상품 옵션 테이블(PRODUCT_OPTION)의 재고(stock) 의 차감 로직에 대하여 충돌이 예상됩니다.

3. 사용자 잔액 충전 및 사용

   한 사용자를 대상으로 동시에 다수의 잔액 충전, 사용 요청 시 충돌이 예상됩니다.


## 개선안 제안

1. 선착순 쿠폰

   선착순 쿠폰의 경우 고경합(high contention) 동시성 문제가 발생할 수 있습니다. 또한 많은 충돌이 예상되고 데이터 정합성 중요도가 비교적 높기에 비관적 락이 적합합니다.

   다만 락 대기 시간에 대한 고려가 더 필요하며 deadlock을 회피하기 위해 트랜잭션별 순서를 확실히 적용해야 하며, 최소 단위 (row-level lock)로만 락을 걸어야 합니다. 또한 deadlock은 100% 예방할 수 없기에 타임 아웃을 설정해야합니다.

2. 상품 재고 감소

   상품 재고 감소의 경우 아주 높은 데이터 정합성 중요도가 아주 높기에 비관적 락이 필요합니다.

3. 사용자 잔액 충전 및 차감

   잔액의 경우 실제 금전 피해로 이어질 수 있는 문제이기에 정합성 보장이 가장 중요합니다. 그렇기에 비관적 락이 필요합니다.


## 해결 방법

1. 선착순 쿠폰

   Lock이 걸린 조회 메서드 추가

    ```java
    @Lock(LockModeType.PESSIMISTIC_WRITE)
    @Query("SELECT c FROM CouponIssueJpaEntity c WHERE c.couponIssueId = :id")
    Optional<CouponIssueJpaEntity> findByIdForUpdate(@Param("id") Long id);
    ```

   쿠폰 차감 서비스의 조회를 해당 메서드로 변경

2. 상품 재고 감소

   Lock이 걸린 조회 메서드 추가

    ```java
    @Lock(LockModeType.PESSIMISTIC_WRITE)
    @Query("SELECT o FROM ProductOptionJpaEntity o WHERE o.optionId = :id")
    Optional<ProductOptionJpaEntity> findByIdForUpdate(@Param("id")Long id);
    ```

   재고 차감 서비스, 재고 증가 서비스의 조회를 해당 메서드로 변경

3. 사용자 잔액 충전 및 차감

   Lock이 걸린 조회 메서드 추가

    ```java
    @Lock(LockModeType.PESSIMISTIC_WRITE)
    @Query("SELECT u FROM UserJpaEntity u WHERE u.userId = :id")
    Optional<UserJpaEntity> findByIdForUpdate(@Param("id") Long id);
    ```

   잔액 차감 서비스, 잔액 충전 서비스의 조회를 해당 메서드로 변경


## 테스트

1. 선착순 쿠폰

   https://github.com/sky96027/e-commerce/commit/b4d522eb7cfe374adfb79e9d92d9ee29d76ec544

   50개의 동시 요청 테스트 추가

   테스트 결과: 성공

2. 상품 재고 감소

   https://github.com/sky96027/e-commerce/commit/3658067c250f099c0d3dc427117d4504056b6d14

   50개의 동시 요청 테스트 추가

   테스트 결과: 성공

3. 사용자 잔액 충전 및 차감

   https://github.com/sky96027/e-commerce/commit/af6f608e8d4bfd3ddc4b2189d7139f6efa6adb69

   50개의 동시 요청 테스트 추가

   테스트 결과: 성공


**테스트 작성 중 실패한 경험**

테스트 코드에 @Transactinal을 선언하여 50개의 요청이 한 트랜잭션으로 묶여 실패했다.

## 한계점

이번 주차에서 비관적 락을 주로 사용하여 문제를 해결하였는데 해당 방법의 한계점은 당므과 같다.

Connection Pool 병목 - 락을 오래 점유할 시 다른 요청이 Connection을 받지 못해 막힌다.

예외 발생 시 락 해제 어려움 - 예외 발생 시 락이 적절히 해제되지 않으면 기아상태에 빠진다.

스케일 아웃 - DB 락이므로 수평 확장에 불리하다.

## 결론

트래픽이 적고 규모가 크지 않은 환경에서는 현재의 방법이 유효할 수 있으나 트래픽이 크고 규모가 큰 환경에서는 현재 방법에 한계가 있다.

그러므로 Redis 기반의 분산 락 환경으로 넘어가야만 한다.

이유는 다음과 같다.
1. 멀티 인스턴스 환경 대응

Redis는 네트워크 상에서 락을 걸 수 있기 때문에, 애플리케이션 서버가 여러 개여도 동시성 제어가 가능하다.

1. 스케일 아웃에 유리

   Redis는 수평 확장이 유리하다. 락을 DB에서 Redis로 변경하면 DB의 부하가 분산된다.

2. 짧은 락 유지와 TTL 설정

   Redis의 락은 TTL을 설정해 락이 영원히 걸리는 것을 방지한다.

3. 성능

   Redis는 메모리 기반으로 DB보다 훨씬 빠르다.

   락 획득 및 해제가 ms 단위로 처리 가능하다.


**Redis 분산 락이 적절한 환경 예시**

| 조건 | 적합 여부 |
| --- | --- |
| 트래픽이 크고, DB 락이 병목인 경우 | ✅ 매우 적합 |
| 다중 서버 환경에서 동기화가 필요한 경우 | ✅ 적합 |
| 락 대상이 DB row가 아닌 비정형 데이터 (ex. 파일, API 호출 등) | ✅ 적합 |
| 락 정합성이 엄격히 필요한 경우 (ex. 은행 이체) | ❌ DB 트랜잭션이 더 적합 |
| 락을 반드시 해제해야 하는 경우 | ✅ Redis는 TTL로 자동 해제 가능 |