## 문제 식별 및 분석

현재 서비스의 주요 서비스에 대해 동시성 문제가 일어날 수 있는 사안들을 정리합니다.

1. 선착순 쿠폰

   선착순 쿠폰의 경우 많은 사용자들의 동시 다발적인 요청으로 인해 쿠폰 발급 테이블(COUPON_ISSUE)의 잔량(remaining) 의 차감 로직에 대하여 충돌이 예상됩니다.

2. 상품 재고 감소

   현재 서비스에서 다수의 사용자가 동일 상품 결제 시 상품 옵션 테이블(PRODUCT_OPTION)의 재고(stock) 의 차감 로직에 대하여 충돌이 예상됩니다.

3. 사용자 잔액 충전 및 사용

   한 사용자를 대상으로 동시에 다수의 잔액 충전, 사용 요청 시 충돌이 예상됩니다.


## 개선안 제안

1. 선착순 쿠폰

   선착순 쿠폰의 경우 고경합(high contention) 동시성 문제가 발생할 수 있습니다. 또한 많은 충돌이 예상되고 데이터 정합성 중요도가 비교적 높기에 비관적 락이 적합합니다.

   다만 락 대기 시간에 대한 고려가 더 필요하며 deadlock을 회피하기 위해 트랜잭션별 순서를 확실히 적용해야 하며, 최소 단위 (row-level lock)로만 락을 걸어야 합니다. 또한 deadlock은 100% 예방할 수 없기에 타임 아웃을 설정해야합니다.

2. 상품 재고 감소

   상품 재고 감소의 경우 아주 높은 데이터 정합성 중요도가 아주 높기에 비관적 락이 필요합니다.

3. 사용자 잔액 충전 및 차감

   잔액의 경우 실제 금전 피해로 이어질 수 있는 문제이기에 정합성 보장이 가장 중요합니다. 그렇기에 비관적 락이 필요합니다.


## 해결 방법

1. 선착순 쿠폰
   Lock이 걸린 조회 메서드 추가

    ```java
   @Lock(LockModeType.PESSIMISTIC_WRITE)
   @Query("SELECT c FROM CouponIssueJpaEntity c WHERE c.couponIssueId = :id")
   Optional<CouponIssueJpaEntity> findByIdForUpdate(@Param("id") Long id);
   ```

   쿠폰 차감 서비스의 조회를 해당 메서드로 변경

2. 상품 재고 감소
   Lock이 걸린 조회 메서드 추가

    ```java
    @Lock(LockModeType.PESSIMISTIC_WRITE)
    @Query("SELECT o FROM ProductOptionJpaEntity o WHERE o.optionId = :id")
    Optional<ProductOptionJpaEntity> findByIdForUpdate(@Param("id")Long id);
    ```

   재고 차감 서비스, 재고 증가 서비스의 조회를 해당 메서드로 변경

3. 사용자 잔액 충전 및 차감
   Lock이 걸린 조회 메서드 추가

    ```java
    @Lock(LockModeType.PESSIMISTIC_WRITE)
    @Query("SELECT u FROM UserJpaEntity u WHERE u.userId = :id")
    Optional<UserJpaEntity> findByIdForUpdate(@Param("id") Long id);
    ```

   잔액 차감 서비스, 잔액 충전 서비스의 조회를 해당 메서드로 변경

